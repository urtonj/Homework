<html><head><title>Pito HW2</title><style type="text/css">ol{margin:0;padding:0}p{margin:0}.c5{vertical-align:top;width:117.0pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c2{line-height:1.0;text-indent:0pt;text-align:center;direction:ltr}.c6{padding-left:0pt;line-height:1.15;direction:ltr;margin-left:36.0pt}.c9{color:#000000;font-size:13pt;font-family:Arial;font-weight:bold}.c0{color:#000000;font-size:11pt;font-family:Arial}.c14{color:#000099;font-size:13pt;font-family:Arial}.c3{line-height:1.15;text-indent:0pt;direction:ltr}.c11{color:#000000;font-size:8pt;font-family:Arial}.c1{width:468.0pt;background-color:#ffffff;padding:72.0pt 72.0pt 72.0pt 72.0pt}.c8{color:#000099;font-size:8pt;font-family:Arial}.c13{list-style-type:disc}.c7{text-decoration:underline}.c12{border-collapse:collapse}.c4{height:11pt}.c10{font-weight:bold}body{color:#000000;font-size:11pt;font-family:Arial}h1{color:#000000;font-size:24pt;margin:0;font-family:Arial;font-weight:bold;padding:0}h2{color:#000000;font-size:18pt;margin:0;font-family:Arial;font-weight:bold;padding:0}h3{color:#000000;font-size:14pt;margin:0;font-family:Arial;font-weight:bold;padding:0}h4{color:#000000;font-size:12pt;margin:0;font-family:Arial;font-weight:bold;padding:0}h5{color:#000000;font-size:11pt;margin:0;font-family:Arial;font-weight:bold;padding:0}h6{color:#000000;font-size:10pt;margin:0;font-family:Arial;font-weight:bold;padding:0}</style></head><body class="c1"><p class="c3"><span class="c0 c10">Jason Urton</span></p><p class="c3"><span class="c0 c10">HW #2</span></p><p class="c3 c4"><span class="c0 c7"></span></p><p class="c3"><span class="c0 c7">A comparison of Android and iPhone architectures</span></p><p class="c3"><span class="c0">First, I will provide a brief description of the Android and iOS operating system architectures, which will be followed by a description of their similarities and differences. </span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3"><span class="c0">The Android operating system is built on top of &nbsp;the Linux kernel, which is uses for memory management, process management, networking, and certain other services. On top of the kernel is a set of native libraries written in C/C++ which enable functionality such as improved window management, graphics rendering, media playback, and SQL connectivity, among other things. Above this sits the Android Runtime, which includes the &ldquo;Dalvik&rdquo; virtual machine (VM) as well as a number of core libraries. The Dalvik VM is an implementation of Java meant specifically for mobile devices. Next comes the Application Framework, which includes basic components that enable application functionality. Finally, the top layer is the Applications layer, which includes the applications that actually make up the customer-facing user interface for Android.</span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3"><img height="254" src="images/image01.png" width="374"></p><p class="c3 c4"><span class="c0"></span></p><p class="c3"><span class="c0">The lowest level of the iOS operating system is the Core OS layer, and encompasses Apple&rsquo;s Darwin kernel as well as a set of additional low-level features upon which the rest of the technologies rest. The next level is Core Services, which includes a number of fundamental system services (like SQL or XML support for example) that most applications use. On top of the Core Services layer is the Media layer, which contains graphics, audio, and video technologies that facilitate the creation of application activities. Next is the Cocoa Touch layer, which acts as the key framework for the creation of iOS applications. Finally, iOS applications themselves are the top layer of the stack. &nbsp; </span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3"><img height="141" src="images/image00.png" width="237"></p><p class="c3 c4"><span class="c0"></span></p><p class="c3"><span class="c0">Based upon the descriptions given, it is clear that the architecture for the Android and iOS operating systems are different is some ways, but are overall quite similar. The following chart lays out the fundamental functionality associated with each layer:</span></p><p class="c3 c4"><span class="c0"></span></p><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr><td class="c5"><p class="c2"><span class="c0 c10">Layer</span></p></td><td class="c5"><p class="c2"><span class="c0 c10">Function</span></p></td><td class="c5"><p class="c2"><span class="c0 c10">Android</span></p></td><td class="c5"><p class="c2"><span class="c0 c10">iOS</span></p></td></tr><tr><td class="c5"><p class="c2"><span class="c0">Application</span></p></td><td class="c5"><p class="c2"><span class="c0">Customer interface</span></p></td><td class="c5"><p class="c2"><span class="c0">Application</span></p></td><td class="c5"><p class="c2"><span class="c0">Application</span></p></td></tr><tr><td class="c5"><p class="c2"><span class="c0">Application Framework</span></p></td><td class="c5"><p class="c2"><span class="c0">Basic components that enable application functionality</span></p></td><td class="c5"><p class="c2"><span class="c0">Application Framework</span></p></td><td class="c5"><p class="c2"><span class="c0">Cocoa Touch</span></p></td></tr><tr><td class="c5"><p class="c2"><span class="c0">Media</span></p></td><td class="c5"><p class="c2"><span class="c0">Graphics, audio, video technologies</span></p></td><td class="c5"><p class="c2"><span class="c0">?</span></p></td><td class="c5"><p class="c2"><span class="c0">Media</span></p></td></tr><tr><td class="c5"><p class="c2"><span class="c0">Runtime</span></p></td><td class="c5"><p class="c2"><span class="c0">VM and core libraries</span></p></td><td class="c5"><p class="c2"><span class="c0">Android Runtime</span></p></td><td class="c5"><p class="c2"><span class="c0">?</span></p></td></tr><tr><td class="c5"><p class="c2"><span class="c0">Libraries</span></p></td><td class="c5"><p class="c2"><span class="c0">Set of system services</span></p></td><td class="c5"><p class="c2"><span class="c0">Libraries</span></p></td><td class="c5"><p class="c2"><span class="c0">Core Services</span></p></td></tr><tr><td class="c5"><p class="c2"><span class="c0">Kernel</span></p></td><td class="c5"><p class="c2"><span class="c0">Basic low-level functionality</span></p></td><td class="c5"><p class="c2"><span class="c0">Linux</span></p></td><td class="c5"><p class="c2"><span class="c0">Darwin</span></p></td></tr></tbody></table><p class="c3 c4"><span class="c0"></span></p><p class="c3"><span class="c0">Each of these layers represents increasing levels of abstraction from the fundamental building blocks involved in any computer-based platform. Both of the models (Android and iOS) are clearly designed to facilitate the creation of applications for developers by providing abstracted layers of functionality that serve to mask complexity and make it simple to interact with basic system processes and resources.</span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3"><span class="c10 c11">Sources: </span></p><ol class="c13"><li class="c6" value="1"><span class="c11">Apple developer manual: </span><span class="c7 c8"><a href="">http://developer.apple.com/library/ios/#documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/iPhoneOSTechnologies/iPhoneOSTechnologies.html#//apple_ref/doc/uid/TP40007898-CH3-SW1</a></span></li><li class="c6"><span class="c11">Hello Android developer manual</span></li></ol><p class="c3 c4"><span class="c11"></span></p><p class="c3 c4"><span class="c11"></span></p><p class="c3"><span class="c0 c7">Hello World Tutorial</span></p><p class="c3"><span class="c0 c10">Screencast</span><span class="c0">:</span></p><p class="c3"><span class="c7 c10 c14"><a href="http://www.youtube.com/watch?v=GVraVO5fPTM">http://www.youtube.com/watch?v=GVraVO5fPTM</a></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3"><span class="c0 c10">Code</span><span class="c0">:</span></p><p class="c3"><span class="c14 c7 c10"><a href="http://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Furtonj%2FHelloAndroid_2&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNFlqBMGmrbYN_-IACqpIWKpectdiQ">https://github.com/urtonj/HelloAndroid_2</a></span></p><p class="c3 c4"><span class="c9"></span></p><p class="c3 c4"><span class="c9"></span></p><p class="c3"><span class="c0 c7">API Review</span></p><p class="c3"><span class="c0">I chose to try out a Spinner demo. Basically a spinner functions as something of a drop down list, allowing the user to select from a list of values. The animation for the list however, is different from a traditional drop down menu, as it actually propagates in its own pop up window. When a user selects an item from the menu, it is displayed on the spinner widget as a the current selection. The spinner is defined in the layout (in &ldquo;main.xml&rdquo;) as follows:</span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3"><span class="c0"> &nbsp; &nbsp;&lt;Spinner </span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;android:id=&quot;@+id/Spinner01&quot;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;android:layout_height=&quot;wrap_content&quot;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;android:layout_width=&quot;fill_parent&quot;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;android:drawSelectorOnTop = &quot;true&quot;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;android:prompt = &quot;@string/planet_prompt&quot;&gt;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp;&lt;/Spinner&gt;</span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3"><span class="c0">This definition is pretty straightforward, the only notable feature I would point out is the line in which the value for the spinner header is referenced (&ldquo;@string/planet_prompt&quot;). This reference looks in the &ldquo;strings.xml&rdquo; resource and retrieves the string with the identifier &ldquo;planet_prompt&rdquo;. If we look in the &ldquo;strings.xml&rdquo; document, we can also see that the spinner values are listed here as a string array as well (planets in this case):</span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3"><span class="c0"> &nbsp; &nbsp;&lt;string-array name=&quot;Planets&quot;&gt;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;&lt;item&gt;Mercury&lt;/item&gt;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;&lt;item&gt;Venus&lt;/item&gt;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;&lt;item&gt;Earth&lt;/item&gt;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;&lt;item&gt;Mars&lt;/item&gt;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;&lt;item&gt;Jupiter&lt;/item&gt;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;&lt;item&gt;Saturn&lt;/item&gt;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;&lt;item&gt;Uranus&lt;/item&gt;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;&lt;item&gt;Neptune&lt;/item&gt;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;&lt;item&gt;Pluto&lt;/item&gt;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp;&lt;/string-array&gt;</span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3"><span class="c0">The relationship between this array and the spinner itself is not actually defined in the XML, but is instead linked up in the code itself (this represents the distinction between declarative and procedural techniques for layout creation). The code that performs this linkage is:</span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;Spinner spinner = (Spinner) findViewById(R.id.Spinner01);</span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;this.mAdapter = ArrayAdapter.createFromResource(this, R.array.Planets,</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;android.R.layout.simple_spinner_dropdown_item);</span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;spinner.setAdapter(this.mAdapter);</span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3"><span class="c0">This code first locates the spinner object, then creates an adapter that contains the strings from the array, and connects the two, such that the string become the list items for the spinner. Finally, the selection that the user makes from the list is displayed with a text view. Again, this value is modified in a procedural fashion (as must be the case for dynamic content of this type). The XML for the text view:</span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3"><span class="c0"> &nbsp; &nbsp;&lt;TextView </span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;android:id=&quot;@+id/SpinnerResult&quot; android:text=&quot;Result&quot;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;android:layout_height=&quot;fill_parent&quot; android:textSize=&quot;10pt&quot;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;android:textStyle=&quot;bold&quot; android:gravity=&quot;center&quot;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp; &nbsp; &nbsp;android:layout_width=&quot;fill_parent&quot;&gt;</span></p><p class="c3"><span class="c0"> &nbsp; &nbsp;&lt;/TextView&gt;</span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0 c7"></span></p><p class="c3 c4"><span class="c0 c7"></span></p><p class="c3 c4"><span class="c0"></span></p></body></html>